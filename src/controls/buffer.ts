import { Curried } from '../compositions/curry.js';
import { Purried, purry } from '../compositions/purry.js';
import { MaybePromise, Series } from './types.js';

async function* _buffer<T>(input: Series<T>, size: number): AsyncGenerator<Awaited<T>> {
    if (size <= 0) throw new RangeError(`"size" must be positive (got ${size.toString()}).`);

    const awaited = await input;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const iterator = (Array.isArray as (v: unknown) => v is readonly any[])(awaited)
        ? awaited.values()
        : awaited;

    const queue: IteratorResult<MaybePromise<T>, unknown>[] = [];
    let pullingCount = 0;
    const eventBus = new EventTarget();

    eventBus.addEventListener('pull', (): void => {
        const next = iterator.next();
        (next instanceof Promise
            ? next
            : // eslint-disable-next-line unicorn/no-unreadable-iife
              (async (): Promise<IteratorResult<Awaited<T>, unknown>> =>
                  ({
                      value: await next.value,
                      done: next.done,
                  }) as IteratorResult<Awaited<T>, unknown>)()
        )
            .then((result: IteratorResult<MaybePromise<T>, unknown>) => {
                queue.push(result);
                pullingCount--;
                eventBus.dispatchEvent(new Event('push'));
            })
            .catch((error: unknown) => {
                eventBus.dispatchEvent(new CustomEvent('error', { detail: error }));
            });
    });

    const pull = () => {
        pullingCount++;
        eventBus.dispatchEvent(new Event('pull'));
    };

    for (let index = 0; index < size; index++) pull();

    const listenError = new Promise((_, reject) => {
        eventBus.addEventListener(
            'error',
            event => {
                // TODO: bug of eslint?
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                event instanceof CustomEvent
                    ? reject(event.detail) // eslint-disable-line @typescript-eslint/prefer-promise-reject-errors
                    : reject(new TypeError(`"error" event is not ErrorEvent.`));
            },
            { once: true },
        );
    });

    const listenNextPush = () =>
        new Promise<false>((resolve: (value: false | PromiseLike<false>) => void) => {
            eventBus.addEventListener(
                'push',
                () => {
                    resolve(false);
                },
                { once: true },
            );
        });

    while (true) {
        const item = queue.shift();
        if (item == undefined) {
            if (pullingCount <= 0) break;
            await Promise.race([listenError, listenNextPush()]);
        } else {
            if (item.done) {
                continue;
            }
            yield await item.value;
            pull();
        }
    }
}

/**
 * Buffers specified number of items and generates results in the resolution order.
 *
 * If the input is a synchronous iterator and generates promises, the promises are executed in parallel and throttled.
 */
export function buffer<T>(...args: Parameters<typeof _buffer<T>>): ReturnType<typeof _buffer<T>>;
export function buffer<T>(
    ...args: Parameters<Curried<typeof _buffer<T>>>
): ReturnType<Curried<typeof _buffer<T>>>;
export function buffer<T>(
    ...args: Parameters<Purried<typeof _buffer<T>>>
): ReturnType<Purried<typeof _buffer<T>>> {
    return purry(_buffer<T>)(...args);
}

/**
 * The promises generated by the given synchronous iterator are executed in parallel and throttled.
 * Alias of {@link buffer}.
 *
 * The results are generated asynchronously in the order of completion, not in the order of input (the first completed result will be emitted first). Please keep in mind that the order of results differs from the order of input.
 *
 * @example
 * ```ts
 * const responses = await Rt.pipe(
 *     urls,
 *     Rt.map.sync(async url => {
 *         const response = await fetch(url);
 *         return await response.json();
 *     }),
 *     Rt.throttle(5), // This maintains up to 5 concurrent HTTP fetch requests.
 *     Rt.toArray(), // The results are ordered by the completion time.
 * );
 * ```
 */
export const throttle = buffer;
